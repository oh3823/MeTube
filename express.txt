------------------------------------------------------------------------
npm, nodejs가 설치되었으면 서버를 만들기 위해서 package.json을 만들기

> npm init

하면 각종 속성들을 타이핑만으로 쉽게 지정해줄 수 있음

설치.txt를 참고해서 패키지들 설치하기
------------------------------------------------------------------------
import express from 'express';
const app = express();

app.listen(4000, ()=> console.log('server listening on port 4000');

// app은 서버이고 브라우저가 request하는 것을 듣고있음

------------------------------------------------------------------------
const handleHome = (req, res) => return res.end();

app.get('/', handleHome);

// 브라우저가 get request를 root에 보냈을 경우 handleHome 함수를 실행시킴
// handleHome 함수를 실행시킬때 인자로 request, respond object를 보냄

// handleHome 함수는 매개변수에 req, res를 저장하고 respond를 return함
// end() 함수는 끝났다고 respond 함
// send('hello') 함수는 hello를 브라우저에 보냄
// send함수에 html을 보낼 수도 있음
------------------------------------------------------------------------

const middleWare = (req, res, next) => {
	console.log('in the middle');
	next();
}

const handleHome = (req, res) => {
	return res.send('Hello');
}

app.get('/', middleWare, handleHome);
// middleWare함수를 호출하고, console.log 한 후에 next()를 만나면 다음 함수(handleHome)을 호출함

------------------------------------------------------------------------
app.use(middleWare);
// global middleWare를 만듦
// 모든 controller 전에 실행됨

//예시
const protectMiddleware = (req, res, next) => {
	const url = req.url;
	if(url === '/protected') return res.send('not allowed');
	next();
}

app.use(protectMiddleware);
app.get('/protected', handleProtected);

// /protected에 접근하려고 할때 handleProtected를 수행하기 전에 protectMiddleware를 먼저 수행함
// 권한 등을 가진 req만 통과시킬수 있음	

------------------------------------------------------------------------

import morgan from 'morgan';

// morgan은 controller (middleware) 를 return 해줌

const logger = morgan('dev'); //morgan에서 'dev' 해당하는 middleware를 반환해서 logger에 저장
app.use( logger );

// morgan은 정교한 log를 남겨주는 middleware가 담겨있는 package
// morgan() 괄호 사이에 combined, dev, common, short, tiny 등이 있는데 dev가 개발자용인것 같다

재밌는거는 컨트롤러에 console.log('hi') 찍어보면

hi
/ GET ...

순으로 로그가 먼저 찍힌다???
분명 middleware로 logger를 놨기 때문에 logger -> 컨트롤러 순으로 실행이 되어야 한다.
morgan이 찍은 로그를 잘 보면 맨 뒤에 120.23 ms 같은 response에 관련된 내용도 나온다.
그리고 morgan내부를 보면 next()를 먼저 실행하고 그 다음에 log를 찍어서라고 한다.
request가 오자마자 바로 찍고 싶다면, 두 번째 인자로 옵션 object를 넣어주면 된다.

const logger = morgan('dev', {immediate: true});

request가 오자마자 즉시 로그를 찍는 옵션이다.
서버가 다운되거나 앱 crash 됐을 때는 response를 못하기 때문에 로그가 아예 안찍힐 수도 있다.
이것을 방지하기 위해서 종종 사용된다고 한다.
그리고 response하기 전에 request가 도착하자마자 로그를 찍기 때문에 response에 대한 내용은 전혀 없다.

------------------------------------------------------------------------

// 라우터 만들기

const globalRouter = express.Router();
const userRouter = express.Router();
const videoRouter = express.Router();	

app.use('/', globalRouter);
app.use('/videos', videoRouter);
app.use('/users', userRouter);

// 서버가 '/'에 해당하는 GET request 를 받을 때 수행되는 middleware
// 서버가 /videos 에 해당하는 GET request 를 받을 때 수행되는 middleware
// 서버가 /users 에 해당하는 GET request 를 받을 때 수행되는 middleware

app.use('/videos', videoRouter);
// 누군가 /videos에 접근하려 하면 videoRouter가 수행됨

videoRouter.get('/watch', handleWatchVideo);

// /videos에 접근한 상태에서 /watch에 get  request를 보내면 handleWatchVideo를 수행함

// app은 전체 서버, .router들은 subserver같은 개념
// 전체 서버에서 middleware로 subserver를 수행하고 subserver가 request들을 수행함


------------------------------------------------------------------------

// router별로 파일을 따로 만들어서 import해줌
// import하기 전에 export해줌

globalRouter.js 에서,

export default globalRouter;   // globalRouter이라는 변수를 export함.
			// 여러 개를 export할 때 default(대표)로 export할 변수를 적어줌

server.js에서,

import globalRouter from './routers/globalRouter';

// 경로에 있는 default(대표) 변수를 import함

------------------------------------------------------------------------
// 여러 변수(함수)를 export하고 import하고 싶다면

// export할 변수(함수) 앞에 export를 붙혀줌

videoController.js에서,
export const watch = (req, res) => res.send('Watch');
export const edit = (req, res) => res.send('Edit');

videoRouter.js에서,
import { watch, edit } from ../controllers/videoController'; //watch, edit을 import함


------------------------------------------------------------------------
//user가 만드는 모든 video를 routing 할 수 없기 때문에 변수(parameter)를 이용하자

app.use('/videos', videoRouter);

videoRouter.get('/:id', watchVideo);

// watchVideo 함수의 req 매개변수의 멤버 params에 :id로 들어온 값이 object로 저장이된다

//경로를 regular expression을 이용해서 유연하게 사용 할 수 있다

userRouter.get('/:id(\\d+)', seeUser);
// userRouter.get('/:id([0-9]+)', seeUser); 와 같음
// \\d는 숫자라는 뜻, 숫자가 1개 이상이면 accept

------------------------------------------------------------------------
// 브라우저에 HTML을 반환해주자
// pug라는 engine을 이용하면 HTML 을 편하게 쓸 수 있음
// >npm i pug 으로 설치하고
// HTML view engine을 pug라고 설정해주자

app.set('view engine', 'pug');
// view engine을 pug로 설정함

// express는 (cwd)/views 안에서 view engine을 찾는다
// HTML을 return할 함수에서 res.render('home'); 으로 return 한다. ( home은 pug파일 이름 )

// cwd는 wetube/ 인데 views는 wetube/src/views/ 에 존재한다. cwd가 wetube인 이유는
// package.json이 node를 실행하고 있기 때문

해결책
1. views를 src 밖으로 꺼낸다. ( 멍청함 )
2. app.set('views', process.cwd() + '/src/views');
// app(express server) 가 보는 디렉토리를 변경할 수 있음. cwd 자체를 바꾸는 것이 아니다.

------------------------------------------------------------------------
// pug에는 #{ .. } 를 이용해서 javascript를 이용할 수 있음

footer &copy; #{new Date().getFullYear()} wetube
javascript를 이용해서 연도 구하기

// pug는 똑같은 코드를 복붙하지 않아도 된다.
// 따로 빼서 필요할 때 마다 include해서 사용하자
// views안에 partials라는 폴더를 만들고 그 안에 자주 사용할 코드 조각(footer.pug)을 적어놓자
// home.pug에서 코드 조각을 불러올 때는 include partials/footer.pug 로 불러오면 된다.

// 개념을 확장하면 코드 틀을 만들어놓고 필요할때마다 불러올 수 있다는 것
// inheritance를 이용해서 똑같은 코드를 반복하지말자
// partials안에 base.pug를 만들고 그 안에 기본 코드를 적자
// base.pug을 확장해서 다른 코드들을 만들자

base.pug파일

doctype html
html(lang='ko')
  head
    title Wetube
  body
    block content
  include partials/footer.pug

// body의 block은 기본 틀에서 변형 할 수 있는 parameter라고 보면 될 것 같다


watch.pug파일

extends base.pug
block content
  h1 watch video

// 이러면 base.pug에 있는 블록에 watch.pug에 적은 h1 watch video가 들어가게 된다

------------------------------------------------------------------------

// base.pug에서 js object 변수를 이용하면 반복을 더 줄일 수 있음

head
  title #{pageTitle} | Wetube

// #{} 사이에 javascript 변수를 받아온다
// base.pug를 rendering 하는 곳에서 변수를 보내준다


export const homepageVideo = (req, res) => {
  res.render("home", { pageTitle: "Home" });
};
// 변수가 여러 개면 여러 개 보내주면 된다
// home.pug는 base.pug의 extend이므로 base에 변수가 있으면 그것 또한 보내줘야 함
// home.pug와 base.pug의 변수의 총 갯수를 보내줘야 한다


export const watchVideo = (req, res) =>
  res.render("watch", { pageTitle: "Watch", videoNum: req.params.id });

// videoNum 변수로 req.params.id를 넘겨줌


block content 
  h1 Watch Video ##{videoNum}

// watch.pug의 block에 videoNum 변수를 받는다
------------------------------------------------------------------------

// mvp.css 홈페이지( https://andybrewer.github.io/mvp/ )에 들어가서 
// link(rel="stylesheet" href="https://unpkg.com/mvp.css") 를 base.pug의 head에 추가해주면 세련된 스타일이 적용된다

------------------------------------------------------------------------

// h1은 하나의 값 (string 혹은 variable)만 갖는다

body
  header
    h1=pageTitle

// 아래와 같은 코드이다

body
  header
    h1 ${pageTitle}


------------------------------------------------------------------------

// pug에서 조건문을 사용할 수 있음

ul
  if user.loggedIn		//로그인되어있으면 logout버튼 표시
    li
      a(href="/logout") logout
  else			//로그아웃되어있으면 login버튼 표시
    li
      a(href="/login") login


------------------------------------------------------------------------

// pug에서 반복문을 사용 할 수 있음
// 배열의 각 원소마다 수행할 명령을 지정할 수 있음

ul
  each video in videos
    li=video

// videos는 배열, video는 videos의 각 원소가 저장되는 변수

------------------------------------------------------------------------

// mixin 은 같은 코드를 반복하는데 그 틀에서 값을 다르게 하고 싶을 때 사용한다

// 코드 조각인데 매개변수를 주어서 같은 템플릿에서 값만 다르게 할 수 있음

// mixins 폴더에 video.pug파일을 만들고

mixin video(info)
  div
    h4=info.title
      ul 
	li #{info.rating}/5;
	li #{info.comments} comments.
	li Posted #{info.createdAt}
	li #{info.views} views.


// home.pug에서
include mixins/video
// 를 하고
  
block content
  h1 Home!
    ul
      each vid in videos
        +video(vid)

// videos의 각 원소 vid에 대해 mixin video(vid) 를 수행한다

------------------------------------------------------------------------

// http get request는 사용자가 서버에서 웹사이트를 가져옴
// 데이터를 읽거나 검색할 때 사용된다. url에 submit한 정보가 저장됨

// http post request는 사용자가 서버로 데이터를 보낼 수 있음
// 서버 상의 데이터 값이나 상태를 바꾸기 위해 사용함

------------------------------------------------------------------------

// anchor의 href 인자의 앞부분에 /를 넣으면 절대 주소가 된다

a(href="/edit") Edit

// 결과 localhost:4000/edit

a(href="edit") Edit

// 결과 localhost:4000/videos/edit (현재 localhost:4000/videos/123에 있음, videos/123/edit이 아님에 주의)


// edit.pug에서 제목을 수정 할 수 있는 form을 만들자
// form(action="")의 action은 form에 작성된 데이터를 어디에 저장할 것인가(DB)를 적는 곳

form(method="POST", action="/save")

// 처럼 하면 /save에 저장한다

------------------------------------------------------------------------

videoRouter.post("/:id([0-9]+)/edit", postEditVideo);
videoRouter.get("/:id([0-9]+)/edit", getEditVideo);

// 구조도 똑같고 router도 똑같으니 좀 더 간편하게 써보자

videoRouter.route("/:id([0-9]+)/edit").get(getEditVideo).post(postEditVideo);

------------------------------------------------------------------------

// 비디오 제목 바꾸기 (http://localhost:4000/videos/1/edit) 페이지에서
// 사용자가 submit 한 data를 POST request에서 추출해야하는데,
// express의 middleware를 사용한다.
// 내가 만든 router middleWare를 사용하기 전에 사용해야한다

// server.js에 middleware 추가
app.use(express.urlencoded({ extended: true }));

// URL 인코딩된 데이터를 파싱할 때 기본으로 파싱할지 확장 형태로 파싱할지 정해준다.
// 만약 extended: false(default)면 JSON 형식으로 못 받아온다.

// express app이 form의 value를 이해하고 javascript(JSON) 형식으로 바꿔준다

//controller에서 req.body에 form의 input의 name과 제출한 data가 object 형식으로 들어있다

console.log(req.body);
//를 하면 {title: data} 형식으로 출력된다.
// key가 title인 이유는 form의 input의 name이 title이기 때문
// input의 name과 사용자가 입력한 data를 쌍으로 처리하기 때문에 input에는 name이 붙어있어야 한다

// 실제 DB에다 req.body.title을 저장해주면 update 완료

------------------------------------------------------------------------

// mongoDB는 object 형식으로 data를 저장한다
// mongoose는 mongodb와 서버를 연결해준다
// db.js에 mongoose를 import해준다

import mongoose from "mongoose";

// url뒤에 이름을 적어주면 그 이름에 해당하는 db에 연결된다
mongoose.connect("mongodb://127.0.0.1:27017/wetube");

// 추가 인자 옵션을 obj형태로 넣어주자

mongoose.connect("mongodb://127.0.0.1:27017/wetube", {
  useNewUrlParser: true,
  useUnifiedTopology: true,
});

------------------------------------------------------------------------

// server.js는 db.js에서 db에 연결하는 과정을 import해준다. file 자체를 import해주자

import "./db";

// db가 연결에 성공하거나 실패한 사실을 console에 띄워주자

const db = mongoose.connection;
db.on("error", (error) => console.log("DB Error", error));

// db에 error event가 발생하면 console log 해라
// on은 event마다 실행하라는 뜻

db.once("open", () => console.log("Connected to DB"));

// once는 한번만 실행하라는 뜻

// import하고 실행해보면 db.js가 맨 나중에 실행됨 = 더 느리다

------------------------------------------------------------------------

// data를 CRUD(create, read, update, delete) 하기전에
// attribute의 schema ( model )을 지정해주자
// schema는 데이터 형식

// src/models directory를 만들고 그 안에 video.js를 만들자

import mongoose from "mongoose";
// mongoose를 import하고 

const videoSchema = new mongoose.Schema({
  title: String,
  description: String,
  createdAt: Date,
  hashtags: [{ type: String }],
  meta: {
    views: Number,
    rating: Number,
  },
});

// video의 틀을 만들어주자
// ex) title 속성은 문자열, description 속성은 문자열로 되어있다
// table의 domain을 미리 정해준 것

const model = mongoose.model("video", videoSchema);

첫 번째 인자는 mongoose가 내부적으로 인식하는 스키마 이름이다.
이름은 나중에 다른 스키마를 참조하거나 할 때 사용된다. (populate 등을 사용하기 위해서)

// video.js에서 만든 videoSchema 형식을 model이라고 하고

export default model;

------------------------------------------------------------------------

// server.js와 db.js는 관련이 없기 때문에 이것들을 통합해주는 init.js를 만들어서 모든 파일들을 import해주자
// videoController.js가 video에 관련된 request들을 처리하기 때문에 videoSchema를 알아야한다
// videoController.js에 models/video.js의 video model을 import해주자

import videoModel from "../models/video";

// default로 export했기 때문에 이름은 상관없다

※ callback이란 무엇인가?
// event가 발생하고 난 다음 호출되는 function을 callback funtion이라고 한다
// 왜 필요한가?
// db는 js가 스스로 처리할 수 없기 때문에 결과가 올 때 까지 기다려야 한다.
// 이것은 javascript의 비동기 처리라고 하는데,
// 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고 다음 코드를 먼저 실행하는 자바스크립트의 특성이라고 한다.
// ex) query를 날리면 mongodb가 응답(event 발생)할 때 까지 기다렸다가 function을 수행해야한다.
// javascript가 스스로 처리할 수 없는 것을 기다리는 방법이다

※ async, await은 무엇인가?

// awiat가 붙어있으면 javascript가 비동기 처리를 하지 않고 결과를 받을 때 까지 기다린다
// 따로 error인자를 받지 않기 때문에 error는 try, catch 구문으로 처리한다
// await은 원칙적으로 비동기 함수에서만 사용 할 수 있기 떄문에 함수 앞에 async를 붙혀준다
// catch 구문의 매개변수로 error를 받을 수 있음
------------------------------------------------------------------------

// callback예시

export const homepageVideo = (req, res) => {
  videoModel.find({}, (err, videos) => {
    console.log(err);
    console.log(videos);
  });
  //console.log('hello');
  return res.render("home", { pageTitle: "Home", videos: [] });
};

// 특이한 점은 console에 hello , error, videos 순으로 출력된다는 점인데,
// videoModel.find가 javascript밖에서 이루어지다보니 더 느리다
// callback을 기다리는 사이에 console.log('hello'); 가 이루어지고, err, videos가 출력되는것

// 혼선을 방지하기 위해 render를 query 응답이 끝난 후에 하도록 코드 순서를 바꿔주자

export const homepageVideo = (req, res) => {
  videoModel.find({}, (err, videos) => {
    // ...
    return res.render("home", { pageTitle: "Home", videos: [] });
  });
};

// callback 함수의 장점 = error을 바로 확인 할 수 있음
// callback 함수의 단점 = function 안에 function을 작성해야한다. callback이 여러 개 있으면 callback 지옥이 된다..

------------------------------------------------------------------------

// async, await 예시 

export const homepageVideo = async (req, res) => {
  try {
    const videos = await videoModel.find({}); // 여기서 결과를 받을 때 까지 기다린다음 진행한다
    return res.render("home", { pageTitle: "Home", videos });
  } catch (error) {
    return res.render("error", { error });
  }
};

// async, await 방식의 장점 = 코드가 직관적이다
// async, await 방식의 단점 = error를 처리하기 위해 try catch 구문을 사용해야한다


------------------------------------------------------------------------

+ Promise 객체를 이용하는 방법도 있다

※ promise는 무엇인가? ( 더 나은 방법 )
// https://joshua1988.github.io/web-development/javascript/promise-for-beginners/
// javascript 비동기 처리에 사용되는 객체
// 3가지 상태가 있다
// 1. pending(대기)
// 2. fulfilled(완료)
// 3. rejected(실패)

new Promise();
//호출 시 pending

new Promise((resolve, reject)=> {
  res();
});
// callback함수를 인자로 가질 수 있음
// res()를 실행하면 fulfilled 상태가 된다
// rej()를 실행하면 reject 상태가 된다

new Promise((resolve, reject)=>{
  resolve(100);
}).then((data)=> console.log(data));

// then method는 fulfilled 상태가 되었을 때 처리 결과 값을 callback 함수로 받아온다

------------------------------------------------------------------------

// controller가 res.render('htmlfile') 를 return하는 이유는?
// render를 두 번 할 수 없음 = return은 단 하나의 method를 수행하고 종료되게 하는 역할임

------------------------------------------------------------------------

// postUploadVideo controller는 upload page에서 user가 보내온 데이터들을 DB에 저장해야한다
// videoModel 모양에 따라 값을 넣어보자

const { title, description, hashtags } = req.body;
const video = new videoModel({
    title,            //title:title과 같다
    description,
    createdAt: Date.now(),
    meta: { views: 0, rating: 0 },
  });

※ 여기서 videoModel은 여러 메소드들이 있는 엄청 큰 몽구스모델 객체인데, 이것으로 인스턴스를 만드는 것이 아니다.
몽구스 모듈 안에 파일을 살펴보면 document 객체 안에는 save 메서드가 있지만, model 객체 안에는 save가 없다.
그런데 const video = new videoModel() 하고 나서 video.save()를 할 수 있는 이유는 new videoModel()이 HydratedDocument 객체를 반환하기 때문이다.
그러니까 video는 model객체가 아니고 document객체인 것이다.

// hashtags는 string으로 이루어진 array 이기 때문에 별도의 가공이 필요하다

hashtags: hashtags.split(","),

// 모든 hashtag 앞에 #을 붙혀주자

hashtags: hashtags.split(",").map(word=>`#${word}`),

------------------------------------------------------------------------

// mongoose는 사소한 실수를 도와준다
// ex) title은 String이지만 Number인 9를 집어넣게 되면 "9"로 변환해준다
// ex) meta.view는 Number이지만 "asdf"를 집어넣게 되면 아예 meta라는 field를 생성하지 않음

------------------------------------------------------------------------

// 실제로 DB에 저장해보자

video.save();

// video obj를 DB에 저장하는 데에 js 비동기 처리를 막기 위해 await를 써주자

await video.save();

// 또는 

await videoModel.create({
    title,
    description,
    createdAt: Date.now(),
    hashtags: hashtags.split(",").map((word) => `#${word}`),
    meta: { views: 0, rating: 0 },
  });

// 만약 field의 이름을 잘못 쓰거나 field에 값을 적어주지 않는다면 해당 field에는 값이 들어가지 않을 것이다

// NULL을 허용하고 싶지 않은 attribute에는 required 옵션을 true로 설정해주자

const videoSchema = new mongoose.Schema({
  title: String,
  description: String,
  createdAt: {type : Date, required : true},
  hashtags: [{ type: String }],
  meta: {
    views: Number,
    rating: Number,
  },
});

// spring boot에서 했던 것과 마찬가지로 데이터들을 받아올 수 있는 그릇이 필요한데
// 그것에 대한 설정을 mongoose의 Schema객체를 만들어서 받아온다.


const model = mongoose.model('video', videoSchema);
export default model;

// model의 이름, model의 그릇(데이터 형태)를 인자로 받아서 모델을 만들고,
// 그 모델을 export해서 user가 입력한 값이 모델로 들어갈 수 있게 하기
------------------------------------------------------------------------

// mongo console에서

> use wetube

// db wetube로 switching 됨

> show collections

// 현재 db의 collection을 보여줌

> db.videos.find()

// db에 videos entity들을 전부 검색

------------------------------------------------------------------------

const videoSchema = new mongoose.Schema({
  title: String,
  description: String,
  createdAt: { type: Date, required: true, default: Date.now },
  hashtags: [{ type: String }],
  meta: {
    views: { type: Number, default: 0 },
    rating: { type: Number, default: 0 },
  },
});

// createdAt의 디폴트 값을 설정해 주어서 일일히 적지 않아도 설정되게끔 하기
// Date.now()는 함수 호출이고, 바로 실행되기 때문에 에러가 날 것
// model이 export되어 create 될 때 실행되도록 괄호를 빼주자


질문! Mongoose 에서 default 는 value 뿐만 아니라 function 도 처리하나요? 
네, 값 뿐만 아니라 함수도 default 값으로 지정할 수 있습니다.
함수를 default 값으로 지정하게 되면 사용하게 될 때마다 해당 함수를 실행시켜 그 반환 값을 기본값으로 가집니다.
자세한 건 아래 사이트를 참고해주세요.

https://mongoosejs.com/docs/defaults.html#default-functions

You can also set the default schema option to a function.
Mongoose will execute that function and use the return value as the default.

------------------------------------------------------------------------

// 스키마의 제목에 최대 글자를 80자로 제한했다고 하면,
// html(pug) input태그의 옵션에서도 제한해주어야 한다.
// 만약 사용자가 html을 수정(최대 길이 삭제)한 후 제출했을 경우
// DB에는 사용자가 입력한 raw 데이터가 그대로 들어가기 때문에
// html파일과 js(스키마 정의) 파일에 둘다 제한을 걸어주는 것이 좋다.

// 스키마 정의 파일

const videoSchema = new mongoose.Schema({
  title: { type: String, trim: true, maxLength: 50 },
  description: { type: String, trim: true, maxLength: 140 },
  createdAt: { type: Date, required: true },
  hashtags: [{ type: String, trim: true }],
  meta: {
    views: Number,
    rating: Number,
  },
});

// upload 페이지를 보여주는 html 파일

block content
	form(method="POST")
		input(name="title" placeholder="Title", required, type="text", maxlength=50)
		input(name="description" placeholder="Description", required, type="text", maxlength=140)
		input(name="hashtags" placeholder="Hashtags, seperated by ,", required, typ e="text")
		input(type="submit" value="Upload")
    
------------------------------------------------------------------------

// DB에 엔터티 만들어서 저장하기

try {
  await model.create({  // model.create 함수를 사용하자. DB는 디스크에 접근하기 때문에 시간이 오래 걸리고, await을 써서 시간을 맞춰주자
    title,
    description,
    hashtags: hashtags.split(',').map((word) => `#${word}`),
  });
} catch (error) {
  if (error) console.log(error);
  return res.render('upload', {
    pageTitle: 'Upload Video',
    errorMessage: error._message,
  });
}


------------------------------------------------------------------------

// DB에 저장되어 있는 obj를 불러오기 위해서 여러 방법이 있는데 그 중 ID로 찾는 방법

export const watchVideo = async (req, res) => {
  const { id } = req.params;
  const video = await model.findById(id);
  return res.render('watch', { pageTitle: video.title, video });
};

// export된 모델에서 id로 비디오를 찾은 후에 저장

// mongoose 내부의 promise로 동기 제어를 하려면 .exec()를 붙혀주면 되는 듯.

export const watchVideo = (req, res) => {
  const { id } = req.params;
  const video = model.findById(id).exec();
  return res.render('watch', { pageTitle: video.title, video });
};


// findById는 Id로 obj를 검색하는 것이고,
// findOne은 조건으로 검색하는 것이다. 예를 들면 title이 hello인 entity 즉, 제목으로 obj를 검색할 수 있음

------------------------------------------------------------------------

// 모든 view의 베이스가 되는 base.pug에 이동 할 수 있는 링크를 만들어주자
nav
  ul 
    li
      a(href="/") Home
      
// 메인 화면으로 가는 링크를 만들어 준 것

------------------------------------------------------------------------

// DB에 들어있는 엔터티의 값을 수정하고 싶을 때 findByIdAndUpdate 함수를 사용

await model.findByIdAndUpdate(id, {
  title,
  description,
  hashtags: hashtags
    .split(',')
    .map((word) => (word.startsWith('#') ? word : `#${word}`)),
});

------------------------------------------------------------------------

// 만약 엔터티 전체가 필요한 작업이 아니면 (엔터티의 유무만 알고 싶을 때는) exists 함수를 사용해주자


const video = await model.exists({ _id: id });  // DB에 _id가 id인 엔터티가 존재하는가?
if (!video) return res.render('404', { pageTitle: 'Video Not Found' }); // 없으면 에러 출력

------------------------------------------------------------------------

// mongoose에서도 middleware를 적용할 수 있다.
// 예를 들면 업데이트 하기 전에 유효성 검사 같은 것, 또는 저장하기 전 특정 필드에 대한 처리

videoSchema.pre('save', async function () {
  hashtags = this.hashtags[0] // hashtag 필드에 대해 다음와 같이 수행한다.
    .split(',')
    .map((word) => (word.startsWith('#') ? word : `#${word}`));
});



// 근데 findByIdAndUpdate 할 때는 save middleware를 호출하지 않는다.
// 따로 만들어주면 됨, 하지만 업데이트 하려는 엔터티에는 접근 할 수 없음

-> 더 나은 방법으로 model안의 함수를 정의해버리자. (스키마의 static 메서드 사용)

// 스키마 정의 파일에서

videoSchema.static('formatHashtags', function (hashtags) {
  return hashtags
    .split(',')
    .map((word) => (word.startsWith('#') ? word : `#${word}`));
});

------------------------------------------------------------------------

// 영상 삭제를 하기 위해서 watch.pug에 delete 버튼을 만들고,
// 그 버튼을 누르면 delete 페이지로 넘어가서 영상을 지워버림
// 이 과정에서 브라우저가 데이터를 줄 필요는 없으므로 post req는 필요없다. -> get만으로 해결

export const deleteVideo = async (req, res) => {
  const { id } = req.params;
  await model.findByIdAndDelete(id);
  return res.redirect('/');
};

// findByIdAndDelete와 findByIdAndRemove가 있는데 delete를 쓰는게 좋다

------------------------------------------------------------------------

// home에 나타나는 영상을 정렬해보자

export const homepageVideo = async (req, res) => {
  const videos = await model.find({}).sort({ createdAt: 'descending' });
  // 만든 시간을 기준으로 내림차순 (최신이 맨 위로 오도록)
  return res.render('home', { pageTitle: 'Home', videos });
};

-----------------------------------------------------------------------

// 비디오 검색할 때 search 페이지에서 사용자가 keyword를 보내면 req.query로 받을 수 있음

// video id는 req.params, form(post)의 데이터는 req.body, form(get)의 데이터는 req.query로 받을 수 있음

req.query는 URL의 파라미터(/search?keyword=hello 에서 keyword=hello 부분)
req.params는 router의 파라미터(/videos/1234 의 1234)

// 검색을 조금 더 유연하게 하기 위해서 regular expression을 사용하자

videos = await model
  .find({
    title: {
      $regex: new RegExp(keyword, 'i'), // keyword를 포함하고 대소문자 구별 없이 검색(i)
    },
  })
  .sort({ createdAt: 'descending' });


// keyword로 시작하는 title만 검색하려면 앞에 ^를, 끝나는 title만 검색하려면 뒤에 $를 붙혀주면 된다

// keyword로 시작하는 단어 검색
new RegExp(`^${keyword}`)

// keyword로 끝나는 단어 검색
new RegExp(`${keyword}$`)

-----------------------------------------------------------------------

// user의 정보를 db에 저장해야 하는데 비밀번호를 그대로 저장하면 매우 위험하다
// 비밀번호 해싱을 이용해서 저장하자

// 해싱을 사용하기 위해서 bcrypt설치

npm i bcrypt

// password를 저장하기 전에 해싱하는 middleware를 만들어주자
// bcrypt를 사용하기 위해서 import bcrypt from 'bcrypt'; 추가 후 user.js에 다음 middleware 추가

userSchema.pre('save', async function () {
  this.password = await bcrypt.hash(this.password, 5);
});

// password가 저장되기 전에 해시함수를 거치게 되고 결과적으로 db에는 h(password)가 저장된다
// saltRound는 해시를 몇 번 할것인지를 정해준다. 3번이면 h(h(h(password)))가 될것이다

-----------------------------------------------------------------------

// 스키마의 멤버를 unique로 설정했다면 그 멤버에 대한 값은 유일해야 한다
// 사용자가 이미 존재하는 username이나 email로 회원가입을 시도한다면 에러 메시지를 내보내도록 하자

const isExist = await userModel.exists({
    $or: [{ username }, { email }], // 두개 중 적어도 하나만 존재해도 존재한다고 인정
  });
if (isExist)
  return res.render('join', {
    pageTitle: 'Join',
    errorMessage: 'Already Exists',
  });
  
-----------------------------------------------------------------------

// 브라우저는 계정이 실제로 생성이 되었든, 중복 생성시도되어 실패되든 200 상태코드를 받으면 성공했다고 인식한다
// 그래서 실제로 username, password가 중복 생성시도 되어 에러 메시지가 나와도 브라우저는 200을 받아서 저장 여부를 물어본다.
// 그냥 render를 하면 200을 받는다. -> status code를 400으로 설정하고 render하자

if (password !== password2)
  return res.status(400).render('join', {
    pageTitle: 'Join',
    errorMessage: 'password does not match',
  });


// 브라우저는 400을 받으면 (error가 생기면) history에 남기지 않는다. 꽤 큰 차이임


-----------------------------------------------------------------------

// model.findOne()은 객체 하나를 찾아서 반환하지만, model.find()는 여러 개를 찾아서 array로 반환한다.
// username은 unique이기 때문에 findOne()이나 find()나 똑같을 것 같지만,
// findOne()은 객체 그 자체가, find()는 객체가 하나 담겨있는 array로 반환된다.

// 따라서 unique인 column을 찾을 때도 findOne()을 사용하는 것이 좋다

-----------------------------------------------------------------------

// 브라우저에서 로그인 했다고 해도 서버에는 그것이 저장되지 않음 -> 로그인하고 redirect 하면 잊어버리게 된다
// 매번 로그인 해도 매번 잊어버리므로 서버는 누가 요청을 날리는지 알 수 없음

// history를 남기기 위해서 쿠키와 세션이 필요하다
// 유저가 서버에 요청을 날렸을 때 브라우저에게 세션ID를 부여하고, 세션ID를 쿠키에 담아 유저에게 넘겨준다.

// 브라우저는 다른 요청을 날릴 때 쿠키를 함께 보내고, 쿠키 속에 들어있는 세션 ID로 유저를 구분한다.
// 쿠키는 브라우저가 관리하고, 세션은 서버가 관리한다. -> 서버에서는 세션만 관리하면 된다.
// 보통 로그인이나  개인정보 등 중요한 정보는 세션에서 관리하고, 그 외 잡다한 정보는 쿠키에서 관리한다.

1. 브라우저가 처음으로 서버에 요청하면, 서버는 해당 브라우저에게 응답과 함께 토큰(세션id)을 준다.
2. 토큰을 받은 브라우저는 이후로 토큰을 쿠키에 넣어서 요청한다. 서버는 브라우저가 보낸 쿠키을 열고 토큰을 확인하면 브라우저를 식별할 수 있다.

+ 여기서 단순 방문 등 세션이 필요없는 경우에는 middleware에서 saveUninitialized 옵션을 false로 설정해서 성능을 높일 수 있다.
saveUninitialized 옵션은 req.session이 바뀌지 않은 경우는 세션 DB에 저장하지 않는다는 뜻이다. 즉 DB용량을 아낄 수 있다.
어느 요청이든 기본적으로는 세션을 만들지만, 로그인 등 세션이 필요한 때만 세션 DB에 저장하는 것 같다.
Uninitialized 세션은 메모리에 load된 express에서 관리해 주겠지??

-----------------------------------------------------------------------

// 세션 기능을 사용하기 위해서 npm 에서 설치
npm i express-session

// 세션을 router middleware 전에 넣게 되면 서버에 접속하는 모든 user에게 텍스트 조각(쿠키)을 주게 된다.

// session은 req안에 들어있다.
// * 세션이 req안에 들어있는 이유는 express가 HTTP request를 처리하고, Controller에 넘겨주기 때문이다.
// 당연히 express가 관여하는 것은 respond를 하기 전까지 이므로 req객체에 들어있어야 할 것이다.


console.log(req.session.id)

// 세션 안에 임의의 멤버를 추가 할 수 있다

req.session.count += 1;

// 로그인 성공했다면 부여받은 세션에 로그인 정보를 추가하자
// postLoginUser 함수 안에 로그인이 성공했다면

req.session.loggedIn = true;
req.session.user = user;

-----------------------------------------------------------------------

// 그렇다면 로그인을 성공해서 세션 안에 로그인 정보가 추가되어 있을때 view(pug)를 다르게 표시하는 방법은 무엇일까

// res의 locals 멤버를 이용하면 된다

// res.locals object는 pug파일에서 바로 사용할 수 있다 = 모든 view 파일에 import되어있는 object이다

res.locals.count = 3;

// 이라고 하면 pug파일에서 

span=count

// 같은 형식으로 사용 할 수 있다. 마치 pug파일의 전역 네임스페이스 같은 느낌

// 다른 예시로 base.pug안에 다음과 같이 쓸 수 있음

if loggedIn                 // 로그인 되어있다면 logout버튼을 표시
  li
    a(href="/logout") Logout
else
  li
    a(href="/join") Join
  li
    a(href="/login") Login
    

// 정리해보면 브라우저에서 서버에 방문 할 때 세션을 나눠주고, 그 세션에 여러 정보를 저장 할 수 있다.
// 그리고 세션에 저장된 정보를 view파일과 공유할 수 있는데, res.locals object를 사용하면 된다.
// 이것을 middleware로 만들어서 사용하면 더 괜찮을 것이다.

// 컨트롤러에서 view파일을 렌더링할 때 변수를 넘겨주는데 이 때 res.locals 오브젝트도 같이 넘겨주는듯 하다

return res.render('videos/watch', { pageTitle: video.title, video });

-----------------------------------------------------------------------

// 이제 실제로 세션 데이터를 DB에 저장해보자
// DB에 저장하기 위해 connect-mongo 설치

npm i connect-mongo

// 그 다음 세션 middleware에 어디에 저장될지를 명시해준다.

app.use(
  session({
    store: MongoStore.create({ mongoUrl: 'mongodb://127.0.0.1:27017/wetube' }),
  })
);

// 세션 데이터가 DB에 저장될 것이고, 서버를 재시작해도 로그아웃 되지 않는다.

-----------------------------------------------------------------------

// 방문한 모든 사람들에 대해 세션ID를 발급하면 세션데이터가 너무 많아질 것이다.
// 로그인한 사용자의 세션만 저장하자

app.use(
  session({
    store: MongoStore.create({ mongoUrl: 'mongodb://127.0.0.1:27017/wetube' }),
    resave: false,
    saveUninitialized: false, // 세션이 만들어지고 수정된 경우(로그인 활동 등)에만 세션ID를 부여함
  })
);

-----------------------------------------------------------------------

// 쿠키에 서명을 하지 않으면 hijack 공격에 취약하다
// 쿠키에 서명을 하기 위해서 어느 문자열로 서명할 것인지를 정해주자

app.use(
  session({
    store: MongoStore.create({ mongoUrl: 'mongodb://127.0.0.1:27017/wetube' }),
    secret: 'Hello',
    resave: false,
    saveUninitialized: false,
  })
);

-----------------------------------------------------------------------

// 브라우저에서 F12를 누르고 application 에 들어가면 Cookies가 메뉴가 있음
// 거기서 현재 브라우저가 가지고 있는 쿠키 정보를 볼 수 있음

// 서버가 쿠키를 주기 전에 몇가지 설정해서 줄 수 있는데, 쿠키의 수명을 정해줄 수 있음

app.use(
  session({
    secret: 'Hello',
    resave: false,
    saveUninitialized: false,
    cookie: { // 브라우저에게 넘길 쿠키의 세부 설정을 정해줄 수 있음
      maxAge: 5000,
    },
    store: MongoStore.create({ mongoUrl: 'mongodb://127.0.0.1:27017/wetube' }),
  })
);


// 하드코딩하기에 민감한 정보들은 .env 파일에 저장해놓자. .env파일은 package.json 파일 옆에 두어야 한다.
// .gitignore 파일에 등록해놓자. 그렇지 않으면 깃허브에 올라가고 숨기는 의미가 없어진다.

// .env 파일 안에 프로퍼티를 저장해주자

COOKIE_SECRET=sifblk43298ualksbf9028734kj
DB_URL=mongodb://127.0.0.1:27017/wetube

// dotenv는 .env파일을 읽기 위한 프로그램이다. 설치해주자

npm i dotenv

// dotenv을 사용하기 위해 secret등이 필요한 파일 맨 앞에 import해주자

import 'dotenv/config';

// js 파일에서 이것을 갖다 쓰려면 process.env.COOKIE_SECRET 으로 사용하면 된다

-----------------------------------------------------------------------

// github로 로그인하기
// https://github.com/settings/developers 에 가서 OAuth app을 만들어주자

// 그러면 client id를 하나 부여받는다

// user를 github를 이용해서 로그인 시키려면
https://github.com/login/oauth/authorize
// 로 redirect 시켜주어야 하는데, 그냥 redirect 시키면 404에러가 나올것이다.

// 여러 매개변수들을 보내주자
// 매개변수는 URL 맨 끝에 ?를 붙혀서 적으면 되고, 매개변수가 여러 개일 경우 &로 구분한다.
https://github.com/login/oauth/authorize?client_id=50625ac54792f755fc39&allow_signup=false

// client_id를 명시해주고, allow_signup은 깃허브 계정이 없으면 깃허브에 먼저 signup 하게 할 것인가? 이다.
// scope parameter는 내가 원하는 범위를 나타낸다

?scope=user:email read:user

// user scope의 email 파트를 원한다는 뜻 -> 그러면 깃허브가 '서버가 이러한 것들을 원한다'고 브라우저에게 알려줄 것
// read scope의 user 파트를 원한다는 뜻. 공백으로 구분지어준다.

-----------------------------------------------------------------------

// 이렇게 되면 URL이 너무 길어지게 되고 헷갈릴 수 있음

// 깃허브로 로그인하는 href를 '/user/github/start' 로 보낸 다음,
// 거기서 github oauth URL로 redirect 해버리자. 그러면 js를 거치기 때문에 문자열을 분해조립해서 쓸 수 있다

// 'user/github/start'로 routing 하는 router를 만들고, startGithubLogin 컨트롤러를 만든다

export const startGithubLogin = (req, res) => {
  const baseURL = 'https://github.com/login/oauth/authorize?';
  //https://github.com/login/oauth/authorize?client_id=50625ac54792f755fc39&allow_signup=false
  const config = {
    client_id: '50625ac54792f755fc39',
    allow_signup: false,
    scope: 'read:user user:email',
  };
};

const params = new URLSearchParams(config).toString();

// config 객체를 만든 후에 그 안에 여러 멤버들을 넣어 놓고
// URLSearchParams 메서드와 toString 메서드를 이용해서 우리가 원하는 string으로 변환하자

-----------------------------------------------------------------------

// github에게 서버가 원하는 scope를 전달해주면 github가 user에게 계속 진행하겠냐고 물어보고
// 유저가 계속 진행하겠다고 응답하면 github callback URL로 유저를 redirect 시켜준다.

// 그렇다면 서버는 유저의 정보에 어떻게 접근하는가?

// github가 callback url로 유저를 redirect시킬 때 code를 넘겨준다.
// 이것을 가지고 깃허브에 POST req를 보낸다

// 유저가 callback url로 보내질 테니 그 url에 해당하는 router와 컨트롤러를 만들어 주자
// 그리고 나서 github로부터 받은 code, client_id, client_secret 등을 함께 묶어서 string으로 만든 후
// 깃허브에 post req를 보낸다.

// node에서 post req를 보내고 데이터를 받아오기 위해서 fetch 함수를 사용해야 하는데
// 이것은 javascript에만 있는 함수이기 때문에 node에서 사용 할 수 있도록 만든 모듈을 설치해주어야 한다.

npm i node-fetch@2.6.1

// 버전 3 이후로 잘 작동 되지 않아서 2.6.1버전으로 다운로드

const data = await fetch(URL, { // 위에서 받은 code, client_id, client_secret을 가지고 조합한 URL에 post req를 보냄
  method: 'POST',
  headers: {
    Accept: 'application/json',
  },
});

// post를 보낸 URL에서 응답을 주고, 그것을 data에 저장한다
// 저장한 데이터를 JSON화 시켜서 로그에 찍어보면 access_token이라는 멤버가 보인다.
// 이것으로 github에 접근할 수 있게 된 것이다. = user의 정보를 얻어올 수 있음

-----------------------------------------------------------------------

// 만약 access_token이 없는 에러가 난다면 어떻게 할것인지 생각해보자.
// login.pug을 다시 보여준 후, 로그인에 에러가 생겼다고 보여주고싶다.

// 그렇다면 res.render('login', {pageTitle:'Login Error'}) 등으로 보여줄 수도 있겠고,
// res.redirect('/login') 한 후 로그인이 실패했다고 알림을 보여주는 방법이 있겠다.

// 전자로 하게 되면 로그인 프로세스에서 view를 렌더링하게 되고, 이는 코드가 꼬이게 될 것 같으므로
// redirect를 해준 후 유저에게 notification을 남겨주자.

-----------------------------------------------------------------------

// 만약 access_token이 있다면?? 그것을 가지고 github내의 user 데이터에 access할 수 있도록
// req를 보내고, respond를 받으면 된다.

// 어디로 req를 보내야 하는지 등은 
// https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps
// 로 가면 친절하게 안내 되어 있다.

const URL = `${baseURL}?${params}`;
const tokenRequest = await (                // 1.
  await fetch(URL, {
    method: 'POST',
    headers: {
      Accept: 'application/json',
    },
  })
).json();
if ('access_token' in tokenRequest) {
  const { access_token } = tokenRequest;    // 2.
  const userRequest = await (
    await fetch('https://api.github.com/user', {
      headers: {
        Authorization: `token ${access_token}`,
      },
    })
  ).json();
  console.log(userRequest);                 // 3.
}

1. code+client_id+client_secret을 가지고 github에 req를 보내면 깃허브에서 access_token을 줄 것.
   client_secret을 보내야 하기 때문에 POST로 보내고, json형식으로 받겠다고 알려주기
2. 받은 access_token을 가지고 URL로 보내면 깃허브에서 user의 정보를 json 형식으로 줄 것이다.
   마찬가지로 access_token을 헤더에 붙혀서 보내주는데, 1회용 토큰이므로 굳이 post로 보내지 않아도 되는듯
3. 깃허브에서 받아온 유저 데이터가 json형식으로 저장되어있고, 이것을 가공해서 사용하면 된다.

-----------------------------------------------------------------------

// 문제는 받아온 user:email이 private이기 때문에 null로 표시되어 있을 수 있다.

const emailData = await (
  await fetch(`${apiURL}/user/emails`, {
    headers: {
      Authorization: `token ${access_token}`,
    },
  })
).json();

// ...../user/emails 에 가서 email 정보를 가져오자 (private이어도 가져올 수 있음)

// 가져온 이메일 중 primary이고 verified된 것을 고르자

const emailObj = emailData.find(
  (email) => email.primary === true && email.verified === true
);

-----------------------------------------------------------------------

// 로그인 하는 방법이 2개 존재한다.
// 1. 그냥 로그인 하는 경우, 2. 깃허브로 로그인 하는 경우

// 그렇다면 그냥 로그인 계정을 가지고 있는 유저가 똑같은 email로 깃허브 로그인을 시도 했을 때 어떻게 할 것인가?
// 이것을 정해주도록 하자

const isExist = await userModel.findOne({ email: emailObj.email }); 
if (isExist) {  // 깃허브로 로그인을 시도한 유저의 이메일이 이미 DB에 존재한다면?? 
  req.session.loggedIn = true;
  req.session.user = user;    // 로그인으로 인정해주고 home으로 redirect
  return res.redirect('/');
} else {
  
}

// 만약 DB에 깃허브 이메일이 없다면 계정을 만들어주자

// 깃허브로 로그인한 계정을 처리하기 위해 스키마에 githubLogin 멤버를 하나 만들어주고, 기본값은 false로 만들어주자
// 이렇게 하면 깃허브로 로그인 했을 때 옵션을 체크해줌으로써 유저가 깃허브로 로그인했는지 아닌지를 구별 할 수 있음

-----------------------------------------------------------------------

// 여러 문제들이 발생 할 수 있다. password는 required 인데 없을수도 있고, 
// 스키마의 middleware는 비밀번호를 가지고 해싱을 해야하는데 비밀번호 필드가 null일 수도 있다. 적절히 잘 고쳐주도록 하자

// 카카오 로그인도 해보자


-----------------------------------------------------------------------

// 로그인 되어있는 사용자는 다시 로그인 페이지에 갈 수 없어야 하고,
// 로그인 되어있지 않은 사용자는  edit 페이지에 갈 수 없어야 한다

// 잘못된 접근을 걸러주는 middleware를 만들고 적용시켜보자


// 로그인 되어있지 않은 사용자가 잘못된 접근 할 때
export const protectorMiddleware = (req, res, next) => {
  if (req.session.loggedIn) {
    next();
  } else {
    return res.redirect('/login');
  }
};

// 로그인 되어 있는 사용자가 잘못된 접근 할 때
export const publicOnlyMiddleware = (req, res, next) => {
  if (req.session.loggedIn) {
    return res.redirect('/');
  } else {
    next();
  }
};

-----------------------------------------------------------------------

// user profile을 업데이트 하고 나면 DB에도, session에도 결과가 적용되어야 한다.

// DB에 업데이트 후 세션에도 업데이트 하는 방법

const updateUser = await userModel.findByIdAndUpdate(   // id로 찾고 업데이트하는데, 기본값은 바뀌기 전 값을 반환한다
  _id,
  {
    name,
    email,
    username,
    location,
  },
  { new: true } // 바뀐 값을 반환하도록 설정
);

req.session.user = updateUser;  // 바뀐 값으로 세션을 업데이트

-----------------------------------------------------------------------

// view 파일이 너무 많으니 폴더에 정리해주자

// user관련된 view들은 users 폴더에,  video 관련된 view들은 videos에 넣어준다
// 주의해야할 점은 기본 view cwd가 src/views 였는데, 파일들이 이동했으므로 컨트롤러에서 render하는 경로를 바꿔주어야 할것이다.

-----------------------------------------------------------------------
change Password

우선 user = userModel.findById()로 저장되어있는 비밀번호를 가져온 후에
사용자가 새로 입력한 pw를 검증하고 바꿔주면 된다

저장할 때 비밀번호를 bcrypt하기 위해서 설정한 미들웨어를 이용하기 위해서 
user.save()를 이용하면 되고, user.save()는 user 오브젝트를 db에 업데이트 시켜준다
user.password = newpassword; 로 바꿔주고 user.save()해주면 된다

-----------------------------------------------------------------------

multer는 파일을 업로드하는 것을 도와주는 middleware
npm i multer로 설치

multer는 multipart/form-data로 인코딩된 데이터만 처리할 수 있다
form 태그에 인코딩 타입을 multipart/form-data로 설정해주면 된다

form(method="POST" enctype='multipart/form-data')


그 다음 multer 라이브러리에 있는 multer()함수를 이용해서 미들웨어의 틀을 만들어주고,
파일을 post로 서버로 전송해주는 컨트롤러 앞에 그 미들웨어를 사용해주면 된다.

middleware.js에 
export const uploadFiles = multer({ dest: 'uploads/' });
로 미들웨어의 틀을 만들어준다.
dest옵션은 파일을 어디로 보낼건지를 정해주는 옵션이고, 여기서는 uploads 폴더안에 저장하도록 했다.
헷갈릴 수 있는데 URL의 route가 아니고 cwd()/uploads라는 서버의 파일시스템이다.

그 다음 file을 post로 서버로 전송해주는 컨트롤러 = edit profile 컨트롤러 앞에
uploadFiles 미들웨어를 넣어주면 되는데, 파일을 몇 개 올릴건지,
어떤 변수명(input 태그의 name 속성)을 가지고 있는지를 명시해주면 된다.

userRouter
  .route('/edit')
  .all(protectorMiddleware)
  .get(getEditUser)
  .post(uploadFiles.single('avatar'), postEditUser);
  
get은 파일을 업로드할 수 없으므로 post 요청에만 multermiddleware를 사용하고
postEditUser 컨트롤러를 호출한다.

그러면 사용자가 upload한 파일은 컨트롤러에서 어떻게 접근할 수 있는가?
req.file이라는 필드를 이용할 수 있게 된다. 이건 그냥 생긴게 아니고 multer가 만들어준것
실제 파일은 /uploads 폴더에 들어있고 그 파일의 path, origin name 등등에 접근할 수 있다

updateUser 오브젝트에 avatarURL 필드를 req.file.path로 채워주면 될 것이다.
근데 사용자가 아바타를 바꾸지 않는다면 어떻게 되는가?? -> req.file을 사용할 수 없다

const updateUser = await userModel.findByIdAndUpdate(
    _id,
    {
      avatarURL: file ? file.path : avatarURL, 
      // 파일이라는 필드가 있으면 사용자가 파일을 업로드 했다는 뜻이고, 
      // 아니면 건드리지 않았다는 뜻이므로 그대로 유지시킨다
      name,
      email,
      username,
      location,
    },
    { new: true }
  );


이렇게 하면 db에 바뀐 파일 경로가 저장될 것이다.
이번엔 view에 현재 아바타를 보여주고 싶은데, 어떻게 하면 좋을까?
edit-profile에 img태그를 추가해서 보여주자
img(src=`uploads/${loggedInUser.avatarURL}` weight='100' height='100')

그런데 브라우저가 파일을 찾으려고 src를 참조해봤더니,
localhost:4000/uploads/... 에는 뭐가 없더라.

브라우저가 서버의 폴더에 접근할 수 있게 해야한다.
브라우저가 서버에 접근 할 수 있는 URL에 라우터를 만들고, 공유할 static 폴더를 적어주자

app.use('/uploads', express.static('uploads'));

이렇게 하면 브라우저가 localhost:4000/uploads에 접근하면, 서버의 /uploads 폴더에 접근할 수 있다.

문제가 없는 것은 아니다. 예를 들면 서버를 이전해야 하는 경우, 서버가 여러 개인 경우
서버에 저장된 파일은 사라지게 될 것이다.
이 문제는 서버를 deploy 할 때 자세히 알아보자.
아마도 amazon s3같은거를 사용할 듯 하다.

-----------------------------------------------------------------------

video upload

파일을 업로드하는 것은 똑같다.
avatar 업로드와 video 업로드를 구별하기 위해서 middleware를 두개 만들자

export const uploadAvatar = multer({
  dest: 'uploads/avatars',
  limits: {
    fileSize: 3000000,
  },
});
export const uploadVideo = multer({
  dest: 'uploads/videos',
  limits: {
    fileSize: 10000000,
  },
});

파일 사이즈 제한 옵션을 넣을 수 있는데, 단위는 바이트이다.

uploadAvatar는 user가 profile을 post로 edit하기 전에,
uploadVideo는 user가 video를 post로 upload하기 전에 끼워주면 될 것 이다.

마찬가지로 upload video의 form에는 enctype을 명시해 주어야 한다.
watch video 템플릿에는 video태그를 이용해서 video를 보여줄 수 있다.

video(src='/'+video.videoURL controls)

그리고 videoModel에 videoURL 혹은 filePath가 없다면 제대로 작동을 안할것이므로
필드를 추가해야 한다.

-----------------------------------------------------------------------

user profile

유저 프로필에는 유저의 정보 + 어떤 비디오를 올렸는지를 보여주어야 한다
그러기 위해서는 나눠져 있는 db collection (user, video)를 뭔가 연결해 주어야 한다

videoModel에는 소유자를, userModel에는 소유한 video들을 저장하는 필드를 만들어주면 될 것이다.

video Schema에 owner라는 필드를 추가하고, 타입과 속성을 적어주자.
user는 고유한 id로 구분되기 때문에 owner를 user 스키마의 id필드로 해주면 될것이다.
근데 user id는 스키마에 수동으로 등록해 주지 않고 자동으로 설정되는데, 이것은 ObjectId라는 타입이다.
JS 기본 타입 중에 ObjectId라는 타입은 없다. 그렇다면 owner의 타입은 뭐라고 적어야 할까?
mongoose의 스키마를 구성하는 타입이니까 몽구스 안에 있을것이다.

  owner: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: 'user',
  },

추가로 어느 오브젝트의 id인지 참조가 필요한데, 참조할 스키마가 있는 모듈의 path를 넣어주면 된다.
여기서는 user 모듈의 userSchema의 id 필드가 필요하다.

video create할때 owner에 user의 id를 넣어주면 된다.

await videoModel.create({
      title,
      description,
      videoURL: file ? file.path : '',
      hashtags: videoModel.formatHashtags(hashtags),
      owner: _id,
    });
    
그러면 비디오를 보는 페이지에서 소유자가 누군지 알려주기 위해서는 어떻게 할까?
watch.pug 템플릿에서 video.owner를 보여주면 된다.
그런데 video.owner는 objectId잖아.. 이걸로는 구분하기 힘들다.
사용자의 이름을 보여주고 싶은데, 이렇게 하려면 watchVideo컨트롤러에서 video를 쿼리하고 나서
video에 있는 소유자로 또 쿼리를 해야한다. 이 작업이 귀찮기도하고, 비효율적이기도 하다.

videoModel 스키마에 owner필드를 적을때 ref 속성을 추가하면 
위와 같은 작업을 mongoose가 해줄 수 있다.

const video = await videoModel.findById(id).populate('owner');

videoModel에서 id로 비디오를 찾고, owner를 populate한다.
=> owner에 있는 값(ObjectId)를 ref(userModel)에 참조해서 그 값으로 채운다!!!

결과적으로 video 변수의 owner 부분에는 userModel 형태의 객체가 들어있을 것이다.



이제 user의 profile에 user가 소유한 동영상들을 보여주는 기능을 구현해보자.

seeUser 컨트롤러(profile 템플릿을 렌더하는 컨트롤러)에서
req.params.id (URL에 있는 id)와 일치하는 user를 찾고,
video들 중에 owner가 방금 찾은 user의 id와 같다면 그 비디오들을 리스트로 보내주면 된다.

위와 같이 한다면 db에 2번 쿼리해야한다.
owner설정과 마찬가지로 userModel을 수정해서 바꿔줄 수 있다.
videos 필드를 추가해준다. 한 유저당 비디오를 여러 개 올릴 수 있기 때문에 videos 필드는 배열이어야 한다.

videos: [
    {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'video',
    },
  ],

다음으로는 user가 video를 upload할 때 videoModel에 owner 필드를 채워서 create함과 동시에
현재 user의 videos 배열에 upload하는 video의 id를 넣어줘야 한다.
그런데 upload하는 video의 id는 우리가 정해주는 것이 아니지만, videoModel.create할 때 
새로 만들어진 video object를 반환해준다. 여기서 video의 id를 추출해 낸 다음에
현재 user의 videos 배열에 append하자.

const videoId = newVideo._id;
    const user = await userModel.findById(_id);
    user.videos.push(videoId);
    await user.save();
    
그 다음에 seeUser에서 video 리스트를 보여주기 위해서 videos를 보낼 때
video들의 id만 보내면 에러가 발생할 것이므로 video객체를 다 보내주자
그렇게 하기 위해서 req.params.id로 찾은 user객체의 videos필드에 있는 id를
실제 video객체로 만들어주면 된다.

=> videos에 있는 값(ObjectId)들을 ref(videoModel)에 참조해서 그 값으로 채운다!!!

user객체의 모양

{
  _id: new ObjectId("63ad2bc7e5fad0e135666a81"),
  email: 'oh3823@naver.com',
  githubLogin: false,
  username: 'oh3823',
  password: '$2b$05$VrPO/xN1cCW7ERgq3ZOD0ubUoV4Qh/DwCHW5hPv4tD2WKsO21kbUW',
  name: 'sanghun',
  location: '1',
  //------------- videos배열의 안쪽 부분이 id를 가지고 있는 video객체로 치환되었다
  videos: [
    {
      meta: [Object],
      _id: new ObjectId("63ad2ec2aeddc680b58ce227"),
      title: 'q',
      description: 'q',
      videoURL: 'uploads\\videos\\ec7e4470cd594ff469072470fa263b49',
      hashtags: [Array],
      owner: new ObjectId("63ad2bc7e5fad0e135666a81"),
      createdAt: 2022-12-29T06:08:02.137Z,
      __v: 0
    }
  ],
  __v: 1
}


-----------------------------------------------------------------------

문제가 있는데, 우리가 미들웨어로 save액션이 있을때마다 비밀번호를 해싱했다.
그런데 user가 비밀번호가 아니라 video를 업로드할 때도 save를 써버려서, h(h(pw)) 처럼 되어버리고
user는 다시 로그인할 수 없게 되었다.

해결 방안 예측) save를 사용하지 않고 update하는 방법 (findByIdAndUpdate 같은 함수를 이용한다거나)

user.js의 userSchema.pre 함수는 userModel에서 새로운 Document를 저장하려고 할 때 middleware로 동작한다.
그러니까 userModel형태 Document 안에 들어있는 메소드이고, 그 오브젝트는 실제 저장하려고 하는 인스턴스.
메소드에서 this는 자기가 속해있는 오브젝트를 가리킨다.

userSchema.pre('save', async function () {
  this.password = await bcrypt.hash(this.password, 5);
});

그러므로 위 코드에서 this는 저장하려는 Document Object가 된다.
중복 해싱을 방지하기 위해서는 DocumentObject의 password가 modified될 때만 pre middleware가 작동하도록 하면 된다.

userSchema.pre('save', async function () {
  if (this.isModified('password'))
    this.password = await bcrypt.hash(this.password, 5);
});

this(저장하려는 document object)의 비밀번호가 수정될 때만 재해싱한다.

-----------------------------------------------------------------------

소유자가 아닌데도 링크 직접 입력해 video를 편집하려는 경우를 막아줘야 한다.

getEditVideo, postEditVideo, deleteVideo 등에서 검증해주면 된다.

if (String(_id) !== String(video.owner))
  return res.status(403).redirect('/');
  
_id는 req.session.user._id이다. 즉 접속한 사용자의 id이다.
video.owner와 _id의 타입이 다르기 때문에 String()으로 감싸주어서 타입을 같게 만든 후 비교하자.

비디오를 지운 후, videoModel에서는 video가 지워졌지만 그 비디오의 소유자의 소유 비디오목록에서는
지워지지 않았다. 시간이 좀 더 걸리겠지만, user를 찾아낸 후 소유한 비디오의 목록에서 삭제된 비디오를 지워주면 속이 편하다.

const user = await userModel.findById(userId);
user.videos.splice(user.videos.indexOf(videoId), 1);
user.save();

-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------

프론트엔드

-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------

백엔드에서 nodejs를 그냥 써도 되지만,
ES6문법, import문 등을 쓰기 위해서 bable-node라는 플러그인을 사용했었다.

마찬가지로 CSS, JS를 그냥 써도 되지만, 더 쉽게 하기 위해서 webpack이라는 것을 사용한다.
모든 브라우저/환경에서 이해할수 있게 변환해주는 것이 webpack이다.

module with dependencies ---webpack---> static assets(css, js)

근데 vanilla webpack은 잘 안쓰인다. 주로 webpack이 포함되어있는 툴을 사용한다.
react, react native등 라이브러리에는 webpack이 내장되어있다.
그래도 webpack은 업계 표준이라서 원리를 알아두는게 좋을듯 하다.

webpack 설치. 둘 다 똑같다.
 
npm i webpack webpack-cli --save-dev
npm i webpack webpack-cli -D

wetube/ 에다가 webpack.config.js파일을 생성해야한다.
이 파일은 vanilla js만 적을 수 있다.
js를 이용해서 무엇을 어떻게 변환하고 어떻게 내보낼건지 configuration을 작성해주면 된다.
구식이기 때문에 import, export default 같은 문법은 사용할 수 없으며,

module.exports = {
   entry:'./main.js',
   output:{
    filename: '...something',
   }
}

이런 식으로 써야한다.
webpack config에는 entry, output이 필요하다. entry는 진입 지점(코드)이고,
output은 말 그대로 변환한 코드를 어떻게 내보낼 것인지를 정해주는 멤버가 될 것이다.
이 두 멤버는 필수이다. 그리고 output멤버의 path는 항상 절대경로여야 한다.

절대경로를 얻어보자. __dirname 이라는 변수는 현재 파일까지의 경로를 말한다.
그럼 __dirname + 'asdfasdf' 로 하면 되겠다~~ = 안됨

path library를 import하고, 그 안의 resolve 메서드를 이용하자.

const path = require('path');

module.exports = {
  entry: 'src/client/js/main.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, 'assets', 'js'),
  },
};

resolve 메서드는 뒤에 오는 인자들을 전부 합쳐서 하나의 경로로 만들어 준다.
이렇게 하는 이유는 output의 path를 확실하게 하기 위함인듯.
만약 path가 없더라도 resolve함수가 만들어준다.


그리고 src/ 에 client라는 폴더를 만들자. 브라우저 사이드에서 실행되는 코드를 여기에 저장하자.
src/client 에 javascript를 저장할 js 폴더를 만들자. 그 안에 main.js 파일을 만들고 코드를 적어보자.

const hello = async () => {
  alert('hello');
  const x = await fetch('');
};

hello();

async, await 같은 문법은 최신 js문법이다. 어떤 브라우저는 지원하지 않을 수도 있다!!
이 파일을 webpack에게 전달해주면 webpack은 구식 브라우저에서도 이해할 수 있도록 코드를 바꿔줄 것이다.

코드를 변환하는 작업을 빠르게 하기 위해서 package.json에서 script를 만들자.

"scripts": {
  "start": "nodemon --exec babel-node src/init.js",
  "assets": "webpack --config webpack.config.js"
},

npm run assets 로 실행하면

wetube/src/assets/js/main.js 가 생기고, 그 안에 변환된 코드가 들어있을 것이다.

(async()=>{alert("hello"),await fetch("")})();

용량을 줄이고 압축시켜버렸다.
다양한 옵션을 추가할 수 있다.

babel은 최신 node 코드를 구식 js로 바꿔주는 플러그인이었다. package.json에서 설정할 수 있다.
프론트엔드 코드에서도 마찬가지로 babel을 사용할 수 있다. package.json이 아니고 webpack.config.json에서 설정해야한다.
babel-loader를 통해 babel 문법을 vanilla js로 바꿔주어야 한다.

module 옵션은 rules를 정할 수 있다. 여기서 rules는 규칙이고, 어떤 파일을 어떤 loader를 통해 변환할 것인지를 정해준다.
우리는 js파일을 babel-loader를 통해 변환해주어야 한다.

npm i babel-loader -D

module: {
    rules: [
      {
        test: /\.js$/,              <-- 어떤 파일을 변환할것인지
        use: {
          loader: 'babel-loader',   <-- 어떤 loader를 사용할 것인지
          options: {
            presets: [['@babel/preset-env', { targets: 'defaults' }]],
          },
        },
      },
    ],
  },

mode는 production 모드와 development 모드가 있는데 production모드는 완전히 한줄로 압축시키는 것이고
development 모드는 말그대로 개발 모드, 코드를 확인할 수 있을 정도로 바꿔준다.
코드 짤 때는 dev모드로 하다가, 배포를 할 때는 production모드로 변환하면 된다.

mode: 'development',


프론트엔드 코드는 src/client/ 에서 작성하고, webpack을 통해 변환된 코드는 assets에 저장될 것이다.
그렇다면 사용자가 프론트엔드 코드를 보기 위해서 어디로 요청해야하는가??
지금이야 router따라 컨트롤러 따라 정적 html을 보여주고 있지만, 이젠 정적 html이 아니고 동적인 페이지를 보여줘야 하는데...
정적 html에서 script 파일을 불러와야 하는데, 이 작업은 브라우저에서 진행되고,
그 말은 브라우저에서 js파일에 접근할 수 있어야 한다는 말이므로 js파일이 들어있는 디렉토리를 브라우저가 접근할 수 있도록 열어줘야 한다.

브라우저가 JS파일을 요청할 수 있도록 폴더 안 파일에 접근할 수 있도록 하자. = 폴더와 URL을 연결시켜주자
file upload할 때 했던것과 마찬가지로, express.static('assets'); 를 라우터에 추가해주자.
그러면 사용자(브라우저)는 /static URL을 통해 서버의 assets폴더에 접근할 수 있게 된다.

app.use('/static', express.static('assets'));


정리 ----

1. 요청
2. 응답으로 html(pug) 렌더링
3. 브라우저가 script를 불러오기 위해서 서버에 있는 js파일을 가져와야함
4. js파일을 브라우저가 찾을 수 있도록 URL을 열고, assets 폴더를 연결해주기

+ 구식 브라우저도 지원하기 위해서 최신 js문법으로 작성한 코드를 vanilla js로 변환해주는 것이 webpack
+ 우리가 짜는 코드는 최신 js문법이고, 변환은 webpack이 해주고, 브라우저는 변환된 코드를 가지고 작동한다.

-----------------------------------------------------------------------

style을 scss로 할것이기 때문에, scss도 일반 css로 변환을 해주어야 한다.
scss -> css로 변환하는 loader가 필요하고, webpack config에도 적어줘야 한다.

loader가 3개 필요하다.
1. scss -> css 변환하는 sass-loader
2. 폰트 불러올때 유용한 css-loader
3. css를 브라우저에 적용시킬 style-loader 

npm install --save-dev sass-loader sass
npm install --save-dev css-loader
npm install --save-dev style-loader

이 loader를 합치자. 참고로 webpack은 use멤버에 들어있는 array에 맨 뒤 loader부터 적용한다.
순서의 역순으로 적어주면 된다.

test: /\.scss$/,
use: ['style-loader', 'css-loader', 'sass-loader'],

scss 파일을 sass - css - style 로더를 통해서 변환해준다.
 
※ CSS파일은 HTML header의 style 태그에 들어가야 하는데, JS에 import하면 style-loader가 자동으로 해준다.

style-loader는 브라우저에 css 코드를 주입하는 역할을 한다.
이 방법의 문제점은 js가 load될 때 까지 기다려야 한다는 것이다. 사용자는 오래 기다려야 한다...
대안으로 css를 js에서 import 해서 style-loader를 통해 injection하지 말고, css를 js와 분리해버리자.
이렇게 한다면 style-loader는 필요없게 된다.
html에 css가 들어있는 형태로 만들고 싶다.
그러기 위해서 css를 추출하는 plugin이 필요하다. (miniCssExtractPlugin)

npm install --save-dev mini-css-extract-plugin



webpack config 파일에 추가해주자.

const MiniCssExtractPlugin = require('mini-css-extract-plugin');  <-- 전역 선언

plugins: [new MiniCssExtractPlugin()], <-- module.exports에 멤버 추가

use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'], <-- 사용할 loader를 변경

이제 css파일을 별도로 분리해준다!!!!
이제 assets에 저장될 css파일과 js파일을 다른 디렉토리에서 관리해주자
css가 저장될 위치는 css를 분리해주는 플러그인에서 지정해주면 될 것이다.

plugins: [
  new MiniCssExtractPlugin({
    filename: 'css/styles.css',
  }),
],

js가 저장될 위치는 output멤버에서 정해주면 된다.
path는 assets까지만 명시해놓고, 나머지는 filename에서 구체적으로 적어주면 된다.

output: {
  filename: 'js/main.js',
  path: path.resolve(__dirname, 'assets', 'js'),
},

이렇게 하면 assets에는 js폴더와 css폴더가 생긴다.
남은 할 일은 html(pug)에서 css파일을 불러오는 것이다.
base.pug에 css를 불러오자.

link(rel="stylesheet" href="/static/css/styles.css")



이제 변환과 불러오기는 모두 끝났고, asset이 만들어질 때 마다 삭제해주고 npm run assets 해주는 일을 자동으로 해주도록 하자.
webpack config에서 watch : true로 설정해놓고,  npm run assets를 해주면 파일 변화를 watching해서 알아서 새로고침, 적용해준다.

watch: true,


또 사용되지 않는 폴더와 파일을 자동으로 지워주는 clean 옵션을 true로 설정해주자.

output: {
  filename: 'js/main.js',
  path: path.resolve(__dirname, 'assets'),
  clean: true,
},

그런데 프론트엔드의 js가 바뀔 때 nodemon이 반응해서 서버도 재시작된다. 이것을 방지해주자.
nodemon이 어떤 파일의 변화를 감지할지 설정해주는 파일을 만들자. nodemon.json

{
  "ignore": ["webpack.config.js", "src/client/*", "assets/*"],   <--- listen을 ignore하는 옵션
  "exec": "babel-node src/init.js"  <-- --exec 옵션을 따로 지정해줄 수도 있다.
}

exec 옵션을 따로 지정해주었으므로 package.json에서 script도 바꿔줄 필요가 있다.

"scripts": {
    "dev:server": "nodemon",
    "dev:assets": "webpack"
  },

nodemon은 자동으로 nodemon.json 파일을 찾아서 script를 실행할 것이고,
webpack은 자동으로 webpack.config.js 파일을 찾아서 script를 실행할 것이다.
뒤에 --config를 붙히고 다른 설정파일을 지정할 수도 있다.

-----------------------------------------------------------------------

변환, development experience 등 자잘한 것들은 끝났다.

awesome font 사용하기

link(rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css")


src/client/scss/config에 설정파일들을 넣자

_reset.scss -> https://meyerweb.com/eric/tools/css/reset/ 에서 코드복붙
_variables.scss -> 기본 색상들을 변수로 저장

src/client/scss/components 에 html components(mixin, partials 등) 넣어서 따로 관리

header.scss
footer.scss 등

src/client/scss/screens 에 html 파일별로 설정해주기

home.scss 등


https://nomadcoders.co/wetube/lectures/2774

자세한 scss 설정은 링크를 참고하기

-----------------------------------------------------------------------

i.fab.fa-github
 | Continue with Github &rarr;

여기서 |는 텍스트가 아이콘 안으로 들어가는 것을 막아준다. | 가 없으면 텍스트가 아이콘이랑 겹쳐버려서 보기 안좋아질것.

-----------------------------------------------------------------------

프론트엔드 JS파일은 필요할때만 로드하는 것이 현명하다.
비디오 플레이어를 구현한 JS는 누군가가 비디오를 보기 위한 요청에만 로드하면 쓸데없는 낭비를 막을 수 있다.

그렇다면 webpack이 코드를 바꿀 때 비디오 플레이어가 필요한 경우에만 변환하면 될 것이다.
main entry와 video player가 필요한 경우 entry를 나눠주자.

entry: {
  main: './src/client/js/main.js',
  videoPlayer: './src/client/js/videoPlayer.js',
},

이렇게만 하면 webpack에서 다른 파일에서 같은 output을 만들고 있다고 오류를 뱉을 것이다.
output의 filename을 entry name에 따라 다르게 하도록 설정해주자.

output: {
    filename: 'js/[name].js',
    path: path.resolve(__dirname, 'assets'),
    clean: true,
  },
  
videoPlayer.js가 로드되어야 하는 view는 watch.pug 하나밖에 없다.
watch.pug에만 script를 추가해주면 된다.
근데 watch.pug는 base를 extend하고있고, base에 block을 만들어서 거기에 추가하는 식으로 해보자

base.pug에서

doctype html
html(lang="ko")
	head
		title #{pageTitle} | #{siteName}
		link(rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css")
		link(rel="stylesheet" href="/static/css/styles.css")
	body
		include partials/header                
		main
			block content
		include partials/footer
	block scripts // 이 줄 추가



watch.pug에서

block scripts
    script(src='/static/js/videoPlayer.js')
    
추가해주면 된다.

-----------------------------------------------------------------------

videoplayer.js 만들기

watch.pug에서

div 
  button#play Play 
  button#mute Mute 
  span#time 00:00/00:00
  input(type='range' min='0' max='1' step='0.1')
  
타입이 range인 input은 볼륨 조절할 때 유용하게 쓰인다.

videoplayer.js에서 element들을 불러오자

const play = document.getElementById('play');
const mute = document.getElementById('mute');
const time = document.getElementById('time');
const volume = document.getElementById('volume');
const video = document.querySelector('video');


video tag는 HTML media element를 상속받는다. html media element의 멤버 + video만의 속성이 존재함

HTML media element docs : https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement

paused, muted 등 유용한 속성과 play(), pause() 등 유용한 메서드들이 있다.
video를 play하기 위해서는 video.play() 메서드를 호출하면 된다. pause는 video.pause()
video를 mute하기 위해서는 video.muted = true; 로 설정해주면 된다. unmute는 video.muted = false;
참고로 unmute할 때 알아서 mute하기 전 볼륨으로 돌아간다. 따로 로직을 작성할 필요가 없다.

unmute를 하면 이전볼륨으로 돌아가기 위해서, 직전에 mute를 누르기 전의 volume을 백업해두는 것도 좋을것 같다.
볼륨을 조절하기 위해서 input(type='range') 태그를 사용했는데, 이것을 volumeRange로 가져왔고,
volumeRange element는 'input'이라는 이벤트를 받을 수 있다.
비슷한 결로 'change'라는 이벤트도 있지만, change는 마우스를 놓았을 때 이벤트가 발생되지만,
input 이벤트는 값이 바뀌면 이벤트를 발생시킨다. 실시간으로 볼륨을 조절하기 위해서는 input이 적절하다.

Mute된 상태에서 볼륨을 조절하면, 자동으로 음소거가 해제되도록 해주자.

const handleVolumeChange = (event) => {
  video.volume = event.target.value;
  if (video.muted) {
    video.muted = false;
    muteBtn.innerText = 'Mute';
  }
};



비디오의 재생 시간을 구현해보자.
비디오가 메인 데이터라면, 나머지 자잘한 데이터들은 메타데이터에 들어있다.
video element가 metadata가 로드되는 이벤트를 듣도록 만들자.
metadate가 로드되면, 그에 따른 값들을 전부 넣어주자.
아마 메타데이터 로드 이벤트는 웹페이지가 로드 되고나서 얼마 지나지 않고 한번만 로드되는 것 같다.
재생시간이 바뀌면 현재 시간을 업데이트해주기 위해서 video가 timeupdate 이벤트를 듣도록 만들어주자.

video.addEventListener('loadedmetadata', handleLoadedMetadata);
video.addEventListener('timeupdate', handleTimeUpdate);

videoContainer를 fullscreen으로 만들 때 f키로도 fullscreen을 토글할 수 있게 하기 위해서는, keydown이벤트를 사용해야한다.
keydown 이벤트는 focus된 요소에 리스너가 있을때 적용된다.

const handleKeydown = (event) => {
  const key = event.key;
  if (key === ' ') {
    event.preventDefault();
    handlePlayClick();
  } else if (key === 'm' || key === 'M') handleMute();
  else if (key === 'f' || key === 'F') handleFullScreen();
};

videoContainer.addEventListener('keydown', handleKeydown);

이렇게 적으면 되는데, videoContainer는 div이고 div는 기본적으로 focus가 안된다.
이럴때는 div에 tabindex라는 속성을 추가해주면 된다. 값은 상관없지만, tab을 눌러서 videoContainer에 접근할 수 없게 하기 위해서는
음수로 세팅해주면 된다.

div#videoContainer(data-id=video._id tabindex='-1')


-----------------------------------------------------------------------

지금까지 만든 것은 사용자가 GET 요청하면 백엔드에서 view 템플릿을 렌더링 해주었다.
사실 보통 웹사이트들이 이렇게 안하고, apiview라는 방법을 이용한다.
프론트에서 백과 통신해서 view를 렌더링한다. 백엔드가 view를 렌더링하지 않는다!!
백엔드에서 렌더링하게되면 뭔가 바뀔 때마다 브라우저가 요청을 보내야하고, 그 때마다 렌더링 해야한다.

비디오의 조회수를 증가시킬 때, 렌더링은 알아서 하고, 백엔드에서는 필요한 일만 해보자.
먼저 프론트에서 조회수가 증가했다고 백에 알리기 위해서 POST로 요청을 보낸다.
백에서는 routing하고, 조회수를 증가시킨 후에, 템플릿을 렌더링하지 않고 성공/실패만 반환한다.
근데 res.status(200) 처럼 보내면 연결이 끝나지 않는다. res.sendStatus(200) 해야 http 코드와 함께 연결이 끝난다.

비디오에 코멘트를 달거나 하면 그것을 적용하기 위해 URL로 요청하였고, 그 URL로 이동했다.
그런데 대부분 게시판은 코멘트를 달아도 URL로 이동하지 않는다. 이것은 브라우저가 URL로 이동해서 백엔드를 동작시키는 것이 아니라
javascript가 URL에 요청할 수 있기 때문이다. fetch() 함수를 사용하면 가능해진다. 옵션에 method : 'post'를 추가해주자.


근데 fetch함수에 URL을 적어서 요청해야하는데, videoplayer.js에서는 video의 id를 모른다. 렌더링된 템플릿에서 video id를 저장해놓아야 한다.
어느 태그의 data 속성을 이용해서 간단한 데이터를 저장할 수 있다.
예를 들면

div#videoContainer(data-id=video._id tabindex='-1')

이렇게 적으면, js에서 videoContainer 요소를 불러온 후에 videoContainer.dataset.id로 video id에 접근할 수 있다.

※ 여기서 왜 POST를 쓰냐면, 사용자가 브라우저에 URL을 타이핑해서 POST 요청을 보낼 수 없기 때문이다.
물론 조회수를 증가하는 것은 GET으로 충분히 할 수 있지만, 올바른 조회수가 되지 못할것이다. (사용자가 언제든지 URL을 타이핑해서 접근할 수 있으니까)
header를 조작하면 POST든 뭐든 요청할 수 있겠지만..
그리고 이론 상 데이터베이스를 조작하는 요청은 GET보다는 POST를 사용한다.

-----------------------------------------------------------------------

video 녹화
stream = navigator.mediaDevices.getUserMedia(); 메서드를 통해서 stream 오브젝트를 반환할 수 있다.

video 태그를 HTML에서 가져와서 stream을 보여줄 수 있다.

video.srcObject = stream;
video.play();

지금 사용자의 미디어가 보여주는 스트림을 그대로 보여준다.


여기서 녹화를 하려면, MediaRecorder 오브젝트를 만들어주어야 한다.

recorder = new MediaRecorder(stream);

MediaRecorder에 stream을 쏙 넣어주면, 그 stream에 대한 recorder오브젝트가 반환된다.
이 오브젝트 가지고 녹화 시작, 종료를 할 수 있다.

recorder.start();  // 녹화 시작
recorder.stop();  // 녹화 종료

그런데 녹화를 종료하면 녹화한 결과물이 어딘가에 저장이 되어야 하는데,  JS는 결과물을 이벤트를 발생시켜서 넘겨주는 방법을 사용했다.
recorder.stop()이 되면 dataavailable 이라는 이벤트가 생성이 되고, 이 이벤트가 발생했을 때 핸들러를 정의해주어야 한다.

recorder.ondataavailable = (e) => {}  // dataavailable 이벤트가 발생했을 때 실행시킬 이벤트 핸들러

이 핸들러가 받는 이벤트 매갭견수에에 녹화된 결과물이 있을 것이다. 여기서 어떤 작업을 수행할지 정의하면 된다.
녹화된 파일은 브라우저의 메모리 어딘가에 저장이 되어있고, 이것은 event.data 오브젝트에 저장이 되어있다.
이것을 js오브젝트로 형태로 만들어서 접근하고 싶다.

videoFile = URL.createObjectURL(event.data)

videoFile은 URL이지만, 실제로 서버에 존재하는 URL은 아니고, 브라우저의 메모리 어딘가를 가리키고 있는 URL이다.
파일이 시작되는 메모리 주소를 가리키고 있다고 생각하면 편할것 같다.

video 태그를 preview stream을 보여주다가, 녹화가 끝나면 녹화된 결과물을 보여주고 싶다.
video.srcObject를 없애주어야 하고, (src가 2개면 안되니까)
video.src 를 파일의 URL로 설정해주어야 한다.

video.srcObject = null;
video.src = videoFile;

-----------------------------------------------------------------------

URL.createObjectURL()

URL.createObjectURL() 정적 메서드는 주어진 객체를 가리키는 URL을 DOMString으로 반환합니다.
해당 URL은 자신을 생성한 창의 document가 사라지면 함께 무효화됩니다.

object
객체 URL을 생성할 File, Blob, MediaSource 객체.
const objectURL = URL.createObjectURL(object)

https://developer.mozilla.org/ko/docs/Web/API/URL/createObjectURL


-----------------------------------------------------------------------

녹화된 비디오를 로컬에 저장할 수 있도록 하자.
일종의 트릭이고, <a>를 만들어서 href를 파일의 URL로 설정하고, download 옵션을 설정해준다.
a.click() 하면 사용자가 일일히 클릭하지 않아도 알아서 실행되고, 다운로드가 될 것이다.
handleDownload에서도 videoFile (파일의 URL)을 사용할 수 있어야 하기 때문에 videoFile 변수를 전역으로 선언해야한다.

const a = document.createElement('a');
a.href = videoFile;
a.download = 'My Recording.webm';
document.body.appendChild(a);
a.click();


※ 만약 다운로드 후 stream을 지우고싶다면 stream track을 모두 지워주면 된다. (여러 미디어가 있다면 track도 여러 개일 것이다)

const tracks = stream.getTracks();
tracks.forEach((track) => track.stop());
stream = null;

-----------------------------------------------------------------------

저장된 동영상을 변환하고 싶다면, 백엔드에서 처리해주어야 한다. 프론트에는 JS만 쓸수있기 때문에 빠르고 컴퓨팅 능력이 요구되는 작업은 무리가 있다.
하지만 webAssembly라는 것이 있는데, 브라우저에서 빠르게 작업을 수행할 수 있는 인터페이스이다.
그리고 비디오/오디오를 마음대로 변환할수 있는 FFmpeg를 같이 사용하면 된다.
용량이 크거나 대기업에서는 백엔드에서 처리해주는 것이 맞긴 하지만, 우리는 돈이 없기 때문에, webAssembly, FFmpeg를 이용해서
컴퓨팅 능력을 우리가 제공하는 것이 아니라 user 로컬에서 사용하도록 만들 것이다.


-----------------------------------------------------------------------
 
사용자에게 메시지를 보내고 싶을 때, alert, 템플릿에 error를 적는 등 여러 방법이 있지만 flash-message라는 것을 이용해 볼것이다.
flash message는 일회용 메시지이고 한번 보여진다음 사라진다.
 
npm i express-flash
 
import flash from 'express-flash';
// ...
app.use(flash());

이렇게 하면 사용 준비 완료
미들웨어로 flash를 사용하는 순간부터 req.flash를 사용할 수 있게 된다.
사용자에게 보여줄 메시지를 서버가 템플릿에 전달해서, 템플릿이 그 메시지를 보여주게 하면 된다.

req.flash('error', 'Not authorized');

이렇게 설정해놓으면, res.locals 안에

{
  messages: {
    errors: 'Not authrized'
  }
}

이렇게 필드가 생긴다. res.locals는 템플릿에서 바로 접근할수 있으니까 messages.error 등에 접근할 수 있다.

if messages.error
	span=messages.error

pug 파일에 이런 식으로 사용 가능하다.

-----------------------------------------------------------------------

비디오에 댓글 달기

comment도 user와 video와 마찬가지로 db에서 관리되어야 한다.
mongoose를 이용해서 schema를 만들고, ref를 설정해주어야 한다.

const commentSchema = mongoose.Schema({
  text: { type: String, required: true },
  createdAt: { type: String, default: Date.now() },
  owner: { type: mongoose.Schema.Types.ObjectId, required: true, ref: 'User' },
  video: { type: mongoose.Schema.Types.ObjectId, required: true, ref: 'Video' },
});


이렇게 하고 form을 만들고, 사용자가 입력한 댓글을 서버로 전송해서 처리해주어야 한다.
서버가 알아야 하는 것은 댓글의 내용, 누가 작성했는가, 언제 작성했는가, 어느 비디오에 작성했는가 이다.
댓글의 내용은 textarea.value, 누가 작성했는지는 session에 들어있고,
언제 작성했는지는 default로 작성한 시점이 정해지고, 어느 비디오에 작성했는가는 템플릿에서 받아온 video Id로 알수있다.

이제 서버로 댓글을 보내면 된다. 우선 textarea에서 submit한 텍스트를 가져오고, 그것을 post로 서버로 보내자.
여기서 지금까지 했던것과 다른 것이 있는데, 지금까지는 post를 요청하고 데이터를 직접 전송하기 위해서는 form만 사용했었는데,
이렇게 데이터만 받아와서 fetch를 사용해서 post로 서버에 전송할 수 있다!!

await fetch(`/api/videos/${videoId}/comment`, {
  method: 'post',
  body: {
    text,
  },
});
  
그런데 사용자가 쓴 댓글을 그대로 post하면 서버쪽에서는 볼 수 없다!!
form에서 post했을 때 서버에서 무엇을 받아왔는지 생각해보면
express.urlencoded({extended:true}) 를 활성화해주어야 form에서 오는 데이터를 서버가 이해할 수 있었다.
마찬가지로 브라우저가 fetch해서 오는 데이터를 서버가 이해할 수 있게 하기 위해서 무언가를 설정해주어야 한다.

app.use(express.text());

이렇게 하면, post의 payload로 온 string을 이해할 수 있게 된다.
근데 이 방법은 body에 obj를 담는 것이 아니라 string을 담아야 한다.
object를 string화 해서 보내는 것이 좋겠다.
그래서 fetch post할 때도 다음과 같이 보내야한다.

await fetch(`/api/videos/${videoId}/comment`, {
  method: 'post',
  body: JSON.stringify({ text }),
});

당연하게도 obj를 stringify했으니까 받을때는 string을 obj로 parsing해야한다.

const { text } = JSON.parse(req.body);



parse하지 않는 방법도 있다. stringify해서 보낸 JSON모양 string을 알아서 js object로 변환시켜주는 미들웨어를 사용하면 된다.

app.use(express.json());

이렇게 하면 string으로 보낸 데이터를 알아서 JS object로 바꿔준다.

const { text } = req.body;

하지만 이렇게 하려면 브라우저에서 express로 string화된 JSON을 보낼 때,
header에 (사실 지금 보내는 것이 JSON이라는) 정보를 추가해주어야 한다.

await fetch(`/api/videos/${videoId}/comment`, {
  method: 'post',
  headers: {
    'Content-type': 'application/json',   // 내용물이 json타입이라는 것을 알려주기
  },
  body: JSON.stringify({ text }),
});


submit되어서, fetch로 텍스트를 보낸 후에 받아와서 DB에 저장하고 템플릿에 보여주기.


export const createComment = async (req, res) => {
  const {
    session: { user },  // 누가 쓴 댓글인지
    body: { text },     // 댓글 내용
    params: { id },     // 어느 비디오에 쓴 댓글인지
  } = req;

  const video = await Video.findById(id);

  if (!video) {
    return res.sendStatus(404);
  }

  const comment = await Comment.create({
    text,
    owner: user._id,
    video: id,
  });

  video.comments.push(comment._id);
  await video.save();
  return res.sendStatus(201);
};


이렇게 하면 DB에 댓글을 저장할 수 있지만, 실시간으로 제출한 댓글이 보이지는 않는다.
새로고침을 해야 보이고, 그러면 같은 request를 계속 보내야 한다. 부하가 걸리는 작업이고, 실제로 realtime이 아니기 때문에 불편하다.
실제로 websocket등을 사용해서 실시간으로 소통하기보다는, 사용자가남긴 댓글을 interactive하게 보여주는 방법이 낫다.

댓글 남김 -> 브라우저가 서버로 전송 -> 서버가 댓글 저장 후 템플릿 전송 -> 브라우저가 렌더링
   ㄴ------> 브라우저가 html document를 생성해서 내가 작성한 댓글을 바로 보여주기

실제로 댓글이 서버에 저장되고 나서 다시 렌더링 하지 않고도 내가 작성한 댓글을 브라우저 script가 interactive하게 보여줄 수 있다.


const handleSubmit = async (event) => {
  event.preventDefault();
  const videoId = videoContainer.dataset.id;
  const text = textarea.value;

  const response = await fetch(`/api/videos/${videoId}/comment`, {
    method: 'post',
    headers: {
      'Content-type': 'application/json',
    },
    body: JSON.stringify({ text }),
  });
  const json = await response.json();

  if (json.status === 201) {
    addComment(text, json.commentId);
  }
  textarea.value = '';
};

여기서 내가 작성한 commet의 id는 서버에서 DB에 저장하려고 create할때 만들어지기 때문에,
브라우저는 방금 작성한 댓글을 전송하고 데이터를 받지 않으면 절대 알수가 없다.
우리는 댓글의 id를 확인해서 댓글 삭제 기능을 만들고 싶기 떄문에, id를 반드시 확인해야한다.

브라우저가 임시 comment를 만들 때, commet의 id를 받아오기 위해서 해야할 일이 있다.
서버에서 comment를 create할 때 만들어진 id를 서버->브라우저 응답 할 때 넘겨주면 된다.

return res.status(201).json({ commentId: comment._id });

status와, object를 JSON화해서 넘겨줄 수 있다.
그럼 브라우저는 아래와 같이 서버에서 응답한 JSON을 열어볼 수 있다.

const response = await fetch(`/api/videos/${videoId}/comment`, {
    method: 'post',
    headers: {
      'Content-type': 'application/json',
    },
    body: JSON.stringify({ text }),
  });
const json = await response.json();

명언을 불러오는 것과 동일한 과정이다.

if (json.status === 201) {
  addComment(text, json.commentId);
}

정상적으로 댓글이 생성되었다면(201), comment를 브라우저에서 바로 보여주자.

const addComment = (text, commentId) => {
  const list = document.querySelector('.video__comments ul');
  const comment = document.createElement('li');
  comment.dataset.id = commentId;
  const icon = document.createElement('i');
  const span = docume snt.createElement('span');
  const del = document.createElement('span');
  del.innerText = ' ❌';
  span.innerText = ' ' + text;
  icon.className = 'fas fa-comment';
  comment.className = 'video__comment';
  comment.appendChild(icon);
  comment.appendChild(span);
  comment.appendChild(del);
  list.prepend(comment);
};


-----------------------------------------------------------------------

배포하기

https://fly.io/docs/languages-and-frameworks/node/
